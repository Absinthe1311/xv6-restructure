# xv6-tailor

本仓库为武汉大学23级弘毅班操作系统实验——xv6裁剪与拼接的代码仓库。提交的代码在仓库的master分支下。

## 项目简介

本项目旨在通过对 xv6 操作系统源码的裁剪与拼接，逐步实现一个简化且可扩展的操作系统。实验分为若干阶段，每个阶段要求同学们从 xv6 的源代码中裁剪出所需部分，并将其添加到本项目中，使系统功能逐步扩展和完善。

## 具体实验步骤

### 任务一：启动至S模式

阶段目标：让系统启动，经过M模式的必要初始化，切换到S模式，然后每个CPU输出一句提示语，之后所有CPU陷入一个死循环。

### 任务二：物理内存管理及内核页表

在上一阶段的基础上，实现对物理内存的管理，对内核构建页表，并让所有CPU
启用页表。本阶段不产生额外的输出，但启用页表后，只要程序执行不错乱，仍可把提示语输出到屏幕上，就基本说明本阶段任务正确完成。

### 任务三：内核态下的中断处理

在上一阶段的基础上，增加对定时器和串口的中断处理。 
定时器按照xv6的方式配置，即周期性的产生中断，两次中断的间隔时间设置为1000000个时钟周期（大约0.1秒）。出于测试目的，本阶段要求定时器每经过30次中断，就向屏幕（串口）输出一个“T”字符。 

### 任务四：启动首个进程

在上一阶段的基础上，启动首个进程，该进程执行两个简单的系统调用，随后
进入死循环即可。即，完成启动后，0号CPU陷在首进程用户态的死循环中，其余CPU陷在main()末尾的死循环中。

### 任务五：系统调用机制和用户堆管理 

在上一阶段的基础上，将系统调用的机制完善起来，并提供sbrk()系统调用，
实现用户堆内存的增长、收缩。  
本阶段仍然只能启动首个进程，但首进程的程序比上一阶段复杂一些，会在其main()函数中执行一些堆分配和释放的测试，随后进入死循环。 
从效果上看，屏幕上首先看到启动过程中每个CPU的输出提示，随后看到进程堆操作触发的若干次系统调用导致的输出，完成启动后，可响应定时器和键盘的中断，每隔大约3秒，屏幕上出现一个“T”字符，并可显示键盘的输入。

### 任务六：进程状态与多进程调度

在上一阶段的基础上，实现进程的多种状态，以及多进程的调度切换。相应的，实现以下系统调用：getpid()、uptime()、fork()、sleep()、wait()、exit()、kill()。此外，为了实现用户态的printf()，对串口增加异步传输的支持，并相应增加write()系统调用。  
从效果上看，屏幕上首先看到启动过程中每个CPU的输出提示，随后看到各个子进程的执行输出。第一个子进程简单死循环，没有任何输出；第二个子进程执行堆操作触发若干次系统调用导致输出，随后退出；第三个子进程执行三次延迟等待后输出，并在退出前向第一个子进程执行kill()；主进程则循环wait()等待子进程结束。完成启动后，可响应定时器和键盘的中断，每隔大约3秒，屏幕上出现一个“T”字符，并可显示键盘的输入。

### 任务七：磁盘盘块读写

在上一阶段的基础上，实现磁盘在QEMU虚拟机上的加载，以及系统对盘块的读写能力。为了方便测试，需要对write()系统调用做一些关于盘块读写测试的扩展。   
本阶段仍然只能启动首个进程，在上一阶段的基础上，对child 1子进程增加了盘块读写测试的调用。程序由老师提供。 从效果上看，屏幕上的输出内容保留了上一阶段的所有输出，期间增加了对某些磁盘盘块的内容输出。 

### 任务八：log层、inode层与exec() 

在上一阶段的基础上，实现文件系统中的日志事务层和inode层，并实现exec()系统调用。  
从效果上看，本阶段的执行输出与上一阶段完全一样。

### 任务九：sh 

在上一阶段的基础上，实现简易的sh程序作为命令行界面。 
我们并未实现文件系统的全部功能，应用程序不具备打开文件读写的能力，所有与此相关的内容都要删减。  
从效果上看，系统启动后终于拥有了一个命令行界面，可以启动执行用户程序了。

## 参考

[xv6源代码](https://github.com/mit-pdos/xv6-riscv.git)
[WHU课程任务书](https://github.com/Absinthe1311/xv6-tailor/blob/main/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%E4%B9%A6%20v2.pdf)

